# üñ±Ô∏è Comprehensive State of Mouse/Drag Event Interactions

**Purpose**: Complete documentation of all mouse event handling patterns in the FYRS project to diagnose drag-related crashes.

**Issue**: Window crashes when dragging (mouse click + drag) on one PC, but works fine on another PC. All buttons work correctly, only drag operations crash.

---

## üìã Table of Contents

1. [Gesture Detection Patterns](#gesture-detection-patterns)
2. [Drag Implementations](#drag-implementations)
3. [Pointer Event Handlers](#pointer-event-handlers)
4. [Scroll Configuration](#scroll-configuration)
5. [Critical Implementation Details](#critical-implementation-details)
6. [Potential Crash Causes](#potential-crash-causes)
7. [Recommended Fixes](#recommended-fixes)

---

## üéØ Gesture Detection Patterns

### 1. Swipeable Card Stack (Horizontal Pan)

**Files**: 
- `lib/modules/swipeable_cards/widgets/swipeable_stack.dart`
- `lib/components/swipeable_card_stack.dart`

**Pattern**: `GestureDetector` with `onPanUpdate` and `onPanEnd`
rt
GestureDetector(
  behavior: HitTestBehavior.translucent,
  onPanUpdate: position == 0 ? _onPanUpdate : null,
  onPanEnd: position == 0 ? _onPanEnd : null,
  onTap: position == 0 ? () => widget.onTap?.call(widget.items[index]) : null,
  child: Container(...),
)**Event Handlers**:

void _onPanUpdate(DragUpdateDetails details) {
  if (_animationController.isAnimating) return;
  
  setState(() {
    _dragOffset += details.delta.dx;
  });
}

void _onPanEnd(DragEndDetails details) {
  if (_animationController.isAnimating) return;
  
  final screenWidth = MediaQuery.of(context).size.width;
  final swipeThreshold = screenWidth * 0.25;
  
  _animationStartOffset = _dragOffset;
  
  if (_dragOffset.abs() > swipeThreshold) {
    _isSwipingOut = true;
    final direction = _dragOffset > 0 ? SwipeDirection.right : SwipeDirection.left;
    
    _animationController.forward(from: 0.0).then((_) {
      // Update index and reset state
      _dragOffset = 0.0;
      _isSwipingOut = false;
      _animationController.value = 0.0;
      setState(() {});
      
      widget.onSwipe?.call(swipedItem, direction);
    });
  } else {
    // Snap back animation
    _isSwipingOut = false;
    _animationController.forward(from: 0.0).then((_) {
      setState(() {
        _dragOffset = 0.0;
      });
      _animationController.reset();
    });
  }
}**Key Points**:
- ‚úÖ Checks `_animationController.isAnimating` before processing
- ‚úÖ Uses `setState()` inside event handlers
- ‚úÖ Guards against null handlers when `position != 0`
- ‚úÖ Uses `HitTestBehavior.translucent` to allow gesture detection
- ‚ö†Ô∏è **CRITICAL**: Only active on `position == 0` (front card)
- ‚ö†Ô∏è **MISSING**: No `mounted` check before `setState()`
- ‚ö†Ô∏è **MISSING**: No check if controller is disposed

---

### 2. Draggable Profile Button

**File**: `lib/components/draggable_profile_button.dart`

**Pattern**: `Draggable` widget with `onDragEnd`

Draggable(
  feedback: Material(...),
  childWhenDragging: Container(),
  onDragEnd: (details) {
    setState(() {
      double newX = details.offset.dx;
      double newY = details.offset.dy;
      
      // Constrain X
      if (newX < 0) newX = 0;
      if (newX > screenSize.width - 56) newX = screenSize.width - 56;
      
      // Constrain Y
      if (newY < 0) newY = 0;
      if (newY > screenSize.height - 56 - bottomPadding - 80) {
        newY = screenSize.height - 56 - bottomPadding - 80;
      }
      
      _position = Offset(newX, newY);
    });
  },
  child: FloatingActionButton(...),
)**Key Points**:
- ‚úÖ Uses `Draggable` widget (built-in Flutter widget)
- ‚úÖ Constrains position within screen bounds
- ‚úÖ Uses `setState()` in `onDragEnd`
- ‚ö†Ô∏è **MISSING**: No `mounted` check before `setState()`
- ‚ö†Ô∏è **MISSING**: No null check on `screenSize`

---

### 3. Calendar Event Dragging (LongPressDraggable)

**File**: `packages/infinite_calendar_view/lib/src/widgets/planner/draggable_event.dart`

**Pattern**: `LongPressDraggable` with `onDragStarted`, `onDragUpdate`, `onDragEnd`

LongPressDraggable(
  feedback: draggableFeedback ?? getDefaultDraggableFeedback(),
  childWhenDragging: const SizedBox.shrink(),
  onDragStarted: () {
    plannerState = context.findAncestorStateOfType<EventsPlannerState>();
    var oldBox = context.findRenderObject() as RenderBox;
    var oldPosition = oldBox.localToGlobal(Offset.zero);
    oldPositionY = oldPosition.dy;
    oldVerticalOffset = plannerState?.mainVerticalController.offset ?? 0;
  },
  onDragUpdate: (details) {
    manageHorizontalScroll(plannerState, context, details);
  },
  onDragEnd: (details) {
    var renderBox = plannerState?.context.findRenderObject() as RenderBox;
    var relativeOffset = renderBox.globalToLocal(details.offset);
    // ... complex calculations ...
    onDragEnd.call(...);
  },
  child: child,
)**Key Points**:
- ‚úÖ Uses `LongPressDraggable` (requires long press to start drag)
- ‚úÖ Uses null-safe operators (`?.`) for plannerState
- ‚ö†Ô∏è **CRITICAL**: Casts `findRenderObject()` to `RenderBox` without type check
- ‚ö†Ô∏è **CRITICAL**: Accesses `context` in callbacks (may be invalid if widget disposed)
- ‚ö†Ô∏è **MISSING**: No validation that `renderBox` is not null

---

### 4. Calendar Slot Resizing (VerticalDragGestureRecognizer)

**File**: `packages/infinite_calendar_view/lib/src/widgets/planner/interactive_slot.dart`

**Pattern**: `RawGestureDetector` with custom `VerticalDragGestureRecognizer` + `GestureDetector` for long press
art
GestureDetector(
  behavior: HitTestBehavior.opaque,
  onTap: () { ... },
  onLongPressStart: (details) { ... },
  onLongPressMoveUpdate: (details) {
    // Complex calculations for slot position
    widget.onChanged(SlotSelection(...));
  },
  child: Stack(
    children: [
      RawGestureDetector(
        gestures: {
          VerticalDragGestureRecognizer: getTopHandleGesture(),
        },
        child: Container(...),
      ),
    ],
  ),
)**Key Points**:
- ‚úÖ Uses custom `VerticalDragGestureRecognizer` via factory
- ‚úÖ Uses `GestureDetector` for long press + drag
- ‚úÖ Checks `startHandleY != 0` before processing updates
- ‚ö†Ô∏è **MISSING**: No null checks on `widget.dayParam` or `widget.slot`
- ‚ö†Ô∏è **MISSING**: No `mounted` check before calling `widget.onChanged`

---

### 5. Calendar Planner Zoom/Pan (Scale + Pointer Events)

**File**: `packages/infinite_calendar_view/lib/src/events_planner.dart`

**Pattern**: `GestureDetector` for scale + `Listener` for pointer events

GestureDetector(
  onScaleStart: canZoom ? zoom.onScaleStart ?? _onScaleStart : null,
  onScaleUpdate: canZoom ? zoom.onScaleUpdate ?? _onScaleUpdate : null,
  onScaleEnd: canZoom ? zoom.onScaleEnd ?? _onScaleEnd : null,
  child: Listener(
    onPointerSignal: _isKeyboardZoomActive ? _onPointerSignal : null,
    onPointerDown: canZoom ? (event) => _onPointerDown() : null,
    onPointerCancel: canZoom ? (event) => _onPointerUp() : null,
    onPointerUp: canZoom ? (event) => _onPointerUp() : null,
    child: IgnorePointer(...),
  ),
)
**Key Points**:
- ‚úÖ Uses `Listener` for low-level pointer events
- ‚úÖ Uses `GestureDetector` for high-level scale gestures
- ‚úÖ Checks `details.pointerCount == 2` for pinch-to-zoom
- ‚ö†Ô∏è **CRITICAL**: Multiple `setState()` calls in pointer handlers
- ‚ö†Ô∏è **MISSING**: No `mounted` checks before `setState()`
- ‚ö†Ô∏è **MISSING**: No checks if controllers are attached

---

## üîÑ Scroll Configuration

**Files**: Multiple calendar/planner files

**Pattern**: `ScrollConfiguration` with `dragDevices`

ScrollConfiguration(
  behavior: ScrollConfiguration.of(context).copyWith(
    scrollbars: false,
    dragDevices: PointerDeviceKind.values.toSet(),
  ),
  child: CustomScrollView(...),
)**Key Points**:
- ‚úÖ Uses `PointerDeviceKind.values.toSet()` to enable all pointer devices
- ‚ö†Ô∏è **CRITICAL**: This enables mouse drag scrolling, which may conflict with custom drag handlers

---

## ‚ö†Ô∏è Critical Implementation Details

### Common Patterns Across All Implementations:

1. **setState() in Event Handlers**
   - All drag handlers use `setState()` to update UI
   - ‚ö†Ô∏è **Issue**: No `mounted` check before `setState()` ‚Üí crash if widget disposed

2. **Context Access in Callbacks**
   - `context.findRenderObject()`, `context.findAncestorStateOfType()`
   - ‚ö†Ô∏è **Issue**: Context may be invalid if widget disposed during drag

3. **Animation Controller State**
   - Checks `_animationController.isAnimating` before processing
   - ‚ö†Ô∏è **Issue**: Doesn't check if controller is disposed

4. **MediaQuery Access**
   - `MediaQuery.of(context).size` accessed in handlers
   - ‚ö†Ô∏è **Issue**: Context may be invalid

5. **RenderBox Casting**
   - `context.findRenderObject() as RenderBox`
   - ‚ö†Ô∏è **Issue**: Cast fails if RenderObject is not RenderBox ‚Üí crash

6. **ScrollController Access**
   - `controller.jumpTo()`, `controller.offset`
   - ‚ö†Ô∏è **Issue**: No check if controller is attached (`hasClients`)

---

## üêõ Potential Crash Causes

### 1. Widget Disposal During Drag (MOST LIKELY)

**Symptoms**: Crash when dragging, especially if dragging quickly or if parent widget rebuilds

**Root Cause**: Event handler tries to access disposed widget's context/state

**Files Affected**: ALL drag implementations

**Solution Pattern**:
void _onPanUpdate(DragUpdateDetails details) {
  if (!mounted || _animationController.isAnimating) return;
  
  setState(() {
    _dragOffset += details.delta.dx;
  });
}---

### 2. RenderBox Cast Failure

**Symptoms**: Crash when accessing `details.offset` or converting coordinates

**Root Cause**: `findRenderObject()` returns null or wrong type

**Files Affected**: 
- `packages/infinite_calendar_view/lib/src/widgets/planner/draggable_event.dart` (Lines 59, 68)

**Solution Pattern**:
final renderObject = context.findRenderObject();
if (renderObject is! RenderBox) return;
final renderBox = renderObject;
final relativeOffset = renderBox.globalToLocal(details.offset);---

### 3. Animation Controller Disposal

**Symptoms**: Crash when animation completes or is interrupted

**Root Cause**: Controller disposed while animation is running

**Files Affected**: 
- `lib/modules/swipeable_cards/widgets/swipeable_stack.dart`
- `lib/components/swipeable_card_stack.dart`

**Solution Pattern**:art
_animationController.forward(from: 0.0).then((_) {
  if (!mounted || _animationController.isDisposed) return;
  // ... rest of code
});---

### 4. Context Invalidation

**Symptoms**: Crash when accessing context in async callbacks

**Root Cause**: Widget disposed before callback executes

**Files Affected**: ALL files with async callbacks

**Solution Pattern**:
WidgetsBinding.instance.addPostFrameCallback((_) {
  if (!mounted) return;
  // ... rest of code
});---

### 5. ScrollController Not Attached

**Symptoms**: Crash when calling `jumpTo()` or accessing `offset`

**Root Cause**: ScrollController not attached to ScrollView

**Files Affected**: 
- `packages/infinite_calendar_view/lib/src/widgets/planner/draggable_event.dart`
- `packages/infinite_calendar_view/lib/src/events_planner.dart`

**Solution Pattern**:t
if (!mainVerticalController.hasClients) return;
mainVerticalController.jumpTo(...);---

## üîß Recommended Fixes

### Priority 1: Add Mounted Checks (CRITICAL)

Add `if (!mounted) return;` at the start of ALL event handlers that call `setState()`.

**Files to fix**:
1. `lib/modules/swipeable_cards/widgets/swipeable_stack.dart` - Lines 68, 76
2. `lib/components/swipeable_card_stack.dart` - Lines 51, 59
3. `lib/components/draggable_profile_button.dart` - Line 45
4. `packages/infinite_calendar_view/lib/src/events_planner.dart` - Lines 569, 576, 593, 606, 612

**Example Fix**:
void _onPanUpdate(DragUpdateDetails details) {
  if (!mounted || _animationController.isAnimating) return; // ADD: !mounted check
  
  setState(() {
    _dragOffset += details.delta.dx;
  });
}---

### Priority 2: Fix RenderBox Cast (CRITICAL)

Replace unsafe casts with type checking.

**File**: `packages/infinite_calendar_view/lib/src/widgets/planner/draggable_event.dart`

**Lines 59, 68**:
// BEFORE (UNSAFE):
var oldBox = context.findRenderObject() as RenderBox;
var renderBox = plannerState?.context.findRenderObject() as RenderBox;

// AFTER (SAFE):
final renderObject = context.findRenderObject();
if (renderObject is! RenderBox) return;
final oldBox = renderObject;

final renderObject2 = plannerState?.context.findRenderObject();
if (renderObject2 is! RenderBox || plannerState == null) return;
final renderBox = renderObject2;
---

### Priority 3: Add Animation Controller Disposal Checks

**Files**: 
- `lib/modules/swipeable_cards/widgets/swipeable_stack.dart` - Lines 68, 76, 88, 107
- `lib/components/swipeable_card_stack.dart` - Lines 51, 59, 71, 91

**Example Fix**:
void _onPanUpdate(DragUpdateDetails details) {
  if (!mounted || 
      _animationController.isDisposed || 
      _animationController.isAnimating) return; // ADD: isDisposed check
  
  setState(() {
    _dragOffset += details.delta.dx;
  });
}

// In animation callbacks:
_animationController.forward(from: 0.0).then((_) {
  if (!mounted || _animationController.isDisposed) return; // ADD: mounted + disposed checks
  // ... rest of code
});---

### Priority 4: Add ScrollController Attachment Checks

**Files**:
- `packages/infinite_calendar_view/lib/src/widgets/planner/draggable_event.dart` - Line 132
- `packages/infinite_calendar_view/lib/src/events_planner.dart` - Lines 563, 587

**Example Fix**:
void manageHorizontalScroll(...) {
  if (plannerState == null) return;
  
  final horizontalController = plannerState.mainHorizontalController;
  final verticalController = plannerState.mainVerticalController;
  
  if (!horizontalController.hasClients || !verticalController.hasClients) return; // ADD: hasClients check
  
  // ... rest of code
}---

### Priority 5: Wrap Critical Context Access in Try-Catch

**Files**: All files accessing context in callbacks

**Example Fix**:
onDragStarted: () {
  try {
    plannerState = context.findAncestorStateOfType<EventsPlannerState>();
    if (plannerState == null || !plannerState.mounted) return;
    
    final renderObject = context.findRenderObject();
    if (renderObject is! RenderBox) return;
    final oldBox = renderObject;
    
    var oldPosition = oldBox.localToGlobal(Offset.zero);
    oldPositionY = oldPosition.dy;
    oldVerticalOffset = plannerState.mainVerticalController.hasClients 
        ? plannerState.mainVerticalController.offset 
        : 0;
  } catch (e) {
    debugPrint('Error in onDragStarted: $e');
    return;
  }
},---

## üìù Files That Need Review (Priority Order)

1. **lib/modules/swipeable_cards/widgets/swipeable_stack.dart** 
   - Lines 68-114 (onPanUpdate, onPanEnd, animation callbacks)
   
2. **lib/components/swipeable_card_stack.dart**
   - Lines 51-98 (onPanUpdate, onPanEnd, animation callbacks)
   
3. **packages/infinite_calendar_view/lib/src/widgets/planner/draggable_event.dart**
   - Lines 54-127 (onDragStarted, onDragUpdate, onDragEnd)
   - Lines 132-154 (manageHorizontalScroll)
   
4. **packages/infinite_calendar_view/lib/src/events_planner.dart**
   - Lines 569-616 (scale handlers, pointer handlers)
   
5. **lib/components/draggable_profile_button.dart**
   - Lines 45-66 (onDragEnd)
   
6. **packages/infinite_calendar_view/lib/src/widgets/planner/interactive_slot.dart**
   - Lines 38-208 (gesture recognizers, long press handlers)

---

## ‚úÖ Testing Checklist

When testing drag fixes:

- [ ] Drag swipeable cards left/right
- [ ] Drag profile button around screen
- [ ] Long-press drag calendar events
- [ ] Drag calendar slot handles (top/bottom)
- [ ] Long-press drag calendar slots
- [ ] Pinch-to-zoom on calendar
- [ ] Mouse wheel scroll during drag operations
- [ ] Rapid drag operations (multiple quick drags)
- [ ] Drag while parent widget rebuilds
- [ ] Drag then immediately navigate away
- [ ] Drag on widgets at screen edges
- [ ] Drag with animations in progress
- [ ] Drag during app backgrounding/foregrounding

---

## üîç Debugging Tips

1. **Add debug prints** in all drag handlers to track which one crashes
2. **Check Flutter version** - different versions may handle drag events differently
3. **Check if crash happens on specific widgets** or all drag operations
4. **Enable Flutter error tracking** to get stack traces
5. **Test with different mouse/touchpad drivers** to rule out hardware issues

---

**Last Updated**: Based on comprehensive codebase analysis of all mouse/drag event implementations.

**Status**: Ready for implementation on the other PC to fix drag crashes.